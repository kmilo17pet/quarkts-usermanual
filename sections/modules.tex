\section{Modules}

\subsection{STimers}
There are several situations where the application doesn't need such hard real-time precision for timing actions and we just need that a section of code will execute when at least, some amount of time has elapsed. For these purposes, STimers (Software-Timers) is the right module to use. 

The STimers implementation doesn't access resources from the interrupt context, does not consume any significant processing time unless a timer has actually expired, does not add any processing overhead to the \textit{sys-tick} interrupt, and does not walk any other data structures. The timer service just takes the value of the existing kernel clock source for reference ($\ t_{sys}$ ), allowing timer functionality to be added to an application with minimal impact.

\input{fig/stimers.tex}

As illustrated in figure \ref{fig:stimers}, the time expiration check is roll-over safe by restricting it, to the only calculation that make sense for timestamps, $\ t_{sys} - X_{T_x}$, that yields a duration namely the amount of time elapsed between the current instant($\ t_{sys}$ ) and the later instant, specifically, the tick taken at the arming instant with \lstinline{(qSTimer_Set())}, ($\ X_{t_i}$ ).
Thanks to modular arithmetic, both of these are guaranteed to work fine across the clock-source rollover(a 32bit unsigned-counter), at least, as long the delays involved are shorter than 49.7 days. 
\medskip

\textbf{Features:}
\begin{itemize}
    \item Provides a non-blocking equivalent to delay function.
    \item Each STimer encapsulates its own expiration (timeout) time.
    \item Provides elapsed and remaining time APIs.
    \item As mentioned before, STimers uses the same kernel clock source, this means the time-elapsed calculation use the \lstinline{qClock_GetTick()} API, therefore, the time resolution has the same value passed when the scheduler has been initialized with \lstinline{qOS_Setup()}.
\end{itemize}

\subsubsection{Using a STimer}
A STimer is referenced by a handle, a variable of type \lstinline{qSTimer_t} \index{\lstinline{qSTimer_t}} and preferably, should be initialized by the \lstinline{QSTIMER_INITIALIZER} constant before any usage. 

To use them, the code should follow a specific pattern that deals with the states of this object. All related APIs are designed to be non-blocking, this means there are ideal for use in cooperative environments as the one provided by the OS itself. To minimize the implementation, this object is intentionally created to behave like a binary object, this implies that it only handles two states, \textit{Armed} and \textit{Disarmed}. 
\medskip

An \textit{Armed} timer means that it is already running with a specified preset value and a \textit{Disarmed} timer is the opposite, which means that it doesn't have a preset value, so consequently, it is not running at all.

The arming action can be performed with \lstinline{qSTimer_Set()} \index{\lstinline{qSTimer_Set}} or \lstinline{qSTimer_FreeRun()} \index{\lstinline{qSTimer_FreeRun}} and disarming with \lstinline{qSTimer_Disarm()}.\index{\lstinline{qSTimer_Disarm}} 
\medskip

Detailed APIs description is presented below. ( For \lstinline{qSTimer_Disarm()} ignore the \lstinline{Time} argument.)
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t qSTimer_Set( qSTimer_t * const obj, const qTime_t Time )
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
qBool_t qSTimer_FreeRun( qSTimer_t * const obj, const qTime_t Time )
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
void qSTimer_Disarm( qSTimer_t * const obj )
\end{lstlisting}

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{obj} : A pointer to the STimer object. 
    \item \lstinline{Time} : The expiration time(must be specified in seconds).
\end{itemize}

Here, \lstinline{qSTimer_FreeRun()} is a more advanced API, it checks the timer and performs the arming. If disarmed, it gets armed immediately with the specified time. If armed, the time argument is ignored and the API only checks for expiration. When the time expires, the STimer gets armed immediately taking the specified time.

\subsubsection*{Return Value}
For \lstinline{qSTimer_Set()} \lstinline{qTrue} on success, otherwise, returns \lstinline{qFalse}.

For \lstinline{qSTimer_FreeRun()} returns \lstinline{qTrue} when the STimer expires, otherwise, returns \lstinline{qFalse}. For a disarmed STimer, also returns \lstinline{qFalse}. 

None for \lstinline{qSTimer_Disarm()}.

\noindent\hrulefill

\medskip
All possible checking actions are also provided for this object, including \lstinline{qSTimer_Elapsed()} \index{\lstinline{qSTimer_Elapsed}}, \lstinline{qSTimer_Remaining()} \index{\lstinline{qSTimer_Remaining}} and \lstinline{qSTimer_Expired()} \index{\lstinline{qSTimer_Expired}}, with the last one being the most commonly used for timing applications.
Finally, to get the current status of the STimer (check if is Armed or Disarmed) the \lstinline{qSTimer_Status()} \index{\lstinline{qSTimer_Status}} API should be used.
\medskip

\begin{lstlisting}[style=CStyle]
qClock_t qSTimer_Elapsed( const qSTimer_t * const obj )
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
qClock_t qSTimer_Remaining( const qSTimer_t * const obj )
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
qBool_t qSTimer_Expired( const qSTimer_t * const obj )
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
qBool_t qSTimer_Status( const qSTimer_t * const obj )
\end{lstlisting}

For this APIs, their only argument, is a pointer to the STimer object.

\subsubsection*{Return Value}
For \lstinline{qSTimer_Elapsed()}, \lstinline{qSTimer_Remaining()} returns the elapsed and remaining time specified in epochs respectively. \\
For \lstinline{qSTimer_Expired()}, returns \lstinline{qTrue} when STimer expires, otherwise, returns \lstinline{qFalse}. For a disarmed STimer, also returns \lstinline{qFalse}. \\
For \lstinline{qSTimer_Status()}, returns \lstinline{qTrue} when armed, and \lstinline{qFalse} for disarmed.

\noindent\hrulefill

\subsubsection*{Usage example:}
The example below shows a simple usage of this object. It is noteworthy that arming is performed once using the \lstinline{FirstCall} flag. This prevents the timer from being re-armed every time the task runs. After the timer expires, it should be disarmed explicitly.
\medskip


\lstinputlisting[style=CStyle]{sec3stimers.c}

\subsection{Finite State Machines (SM)}
The state machine is one of the fundamental programming patterns that are most commonly used. This approach breaks down the design into a series of finite steps called "states" that perform some narrowly defined actions. Every state can change to another as a consequence of incoming stimuli also called events or signals. This elemental mechanism allows designers to solve complex engineering problems in a very straightforward way.
Knowing the importance of this approach in the development of embedded applications, the OS adopts this design pattern as a kernel module.

In an effort to maximize efficiency and minimize complexity, the module implements the basic features of the Harel statecharts to represent hierarchical state machines. This features form a proper subset that approaches in a very minimalist way, some of the specifications of the UML statecharts, including:

\begin{itemize}
    \item Nested states with proper handling of group transitions and group reactions.
    \item Guaranteed execution of entry/exit actions upon entering/exiting states.
    \item Straightforward transitions and guards.
\end{itemize} 

In addition to this, the provided implementation also features a powerful coding abstraction including transition tables and timeout signals, allowing to build scalable solutions from simple state-machines to complex statecharts. 

\subsubsection{The provided approach}

In QuarkTS, a state-machine must be instantiated with an object of type \lstinline{qSM_t}. States are represented as instances of the \lstinline{qSM_State_t} object. Here, the state machines are constructed by composition.

\input{fig/fsmdesign}

One important attribute of the \lstinline{qSM_State_t} object is the callback function, which is used to describe the behavior specific to the state. Also there is a pointer to the parent state to define nesting of the state and its place in the hierarchical topology.
As shown in figure \ref{fig:fsmdesign}, a state machine consist of a least one state the "top level" state.
So concrete state machine are built by adding an arbitrary number states and defining callback functions.

\subsubsection{Setting up a state machine : \texorpdfstring{\lstinline{qStateMachine_Setup}}{qStateMachine_Setup} }
Like any other OS object, a Finite State Machine (FSM) must be explicitly initialized before it can be used. The \lstinline{qStateMachine_Setup()} API \index{\lstinline{qStateMachine_Setup}}  initializes the instance, sets the callback for the top state, sets the initial state and the surrounding callback function.
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t qStateMachine_Setup(qSM_t * const m, qSM_StateCallback_t topCallback, 
                            qSM_State_t * const childstart, 
                            qSM_SurroundingCallback_t surrounding, void *Data )
\end{lstlisting}

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{m} : A pointer to the FSM object.
    \item \lstinline{topCallback} :  The callback for the "Top" state. This argument is a pointer to a callback function, returning \lstinline{qSM_Status_t} and with a \lstinline{qSM_Handler_t} variable as input argument.
    \item \lstinline{childstart} : The first state to be executed (initial-state). 
    \item \lstinline{Surrounding} : The surrounding callback function. To ignore pass \lstinline{NULL}.
    \item \lstinline{Data} : Represents the FSM arguments. To ignore pass \lstinline{NULL}. All arguments must be passed by reference and cast to \lstinline{(void *)}. Only one argument is allowed, so, for multiple arguments, create a structure that contains all of the arguments and pass a pointer to that structure. 
\end{itemize}  

\begin{tcolorbox}
\ArrowBoldDownRight \textit{Note}: For the \lstinline{Surrounding} argument, a \lstinline{NULL} value will act as a "disable" action.
\end{tcolorbox}


\subsubsection{Subscribing states and defining callbacks: }
State  machines  are constructed by composition, therefore, the topology of a state machine is determined upon construction.
In this module implementation. there are not distinction between composite states(states containing substates) and leaf states. All states are potentially composite. 
The API \lstinline{qStateMachine_StateSubscribe} should be used to initialize the state and define its position in the topology.
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t qStateMachine_StateSubscribe( qSM_t * const m, 
                                      qSM_State_t * const state, 
                                      qSM_State_t * const parent, 
                                      qSM_StateCallback_t StateFcn, 
                                      qSM_State_t * const ChildStart, 
                                      const qBool_t KeepHistory )
\end{lstlisting}

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{m} : a pointer to the FSM object.
    \item \lstinline{state} :  A pointer to the state object.
    \item \lstinline{parent} : A pointer to the parent state. Pass \lstinline{NULL} if this state its a child of the \textit{Top} state.
    \item \lstinline{StateFcn} : The handler function associated to the state. 

                                 Prototype: \lstinline{ qSM_Status_t xCallback( qSM_Handler_t h ) }
    \item \lstinline{ChildStart} : The first child-state to be executed if the subscribed state its a parent in an hierarchical pattern. To ignore pass \lstinline{NULL} as argument.
    \item \lstinline{KeepHistory} : \lstinline{qTrue} to keep the shallow history of the subscribed state.
\end{itemize}  

A state callback-functions takes a \lstinline{qSM_Handler_t} object as input argument and returns a \lstinline{qSM_Status_t} value. An example is shown in the following code snippet:
\medskip

\begin{lstlisting}[style=CStyle]
qSM_Status_t ExampleState_Callback( qSM_Handler_t h ){
    /* TODO: State code */
    return qSM_STATUS_EXIT_SUCCESS;
}
\end{lstlisting} 


\subsubsection{The state callback handler : Performing transitions and retrieving data : }

Because callback functions are methods derived from the state machine object, they have direct access to some attributes via the \lstinline{qSM_Handler_t} argument. 
The usage of this object it's required to make the FSM moves between states and additionally get extra data. The provided attributes are:

\begin{itemize}
    \item \lstinline{NextState} : Desired next state. The application writer should change this field to another state to produce a state transition in the next FSM's cycle. Changing this field will only take effect when the states is executed under user-defined signals or in the absence of signals \lstinline{QSM_SIGNAL_NONE}.
    \item \lstinline{StartState} :  Desired nested initial state. The application writer should change this field to set the initial state if the current state its a parent(or composite state). Changing this field will only take effect when the state is executed under the \lstinline{QSM_SIGNAL_START} signal.
    \item \lstinline{Signal} (read-only): Received signal. Can have any of the following values: 
    \begin{itemize}
        \item \lstinline{QSM_SIGNAL_NONE} if no signal available.
        \item \lstinline{QSM_SIGNAL_ENTRY} if the current state has just entered from another state.
        \item \lstinline{QSM_SIGNAL_START} to set nested initial transitions by using the \lstinline{StartState} attribute.
        \item \lstinline{QSM_SIGNAL_EXIT} if the current state has just exit to another state.
        \item Any other user-defined signal will reside here, including the \lstinline{QSM_SIGNAL_TIMEOUT(#)} signals.
    \end{itemize}    
    \item \lstinline{Status} (read-only): The exit(or return) status of the last state. Should be used in the \textit{Surrounding} callback to perform the corresponding actions for every value. On states callback will take the value \lstinline{qSM_STATUS_NULL};
    \item \lstinline{machine} (read-only):  A generic pointer to the container state machine.
    \item \lstinline{Data} (read-only): State-machine associated data. If the FSM is running as a task, the associated event data can be queried through this field. (here, a cast to \lstinline{qEvent_t} is mandatory).
\end{itemize}


Within the callback function of every state, only one level of dispatching (based on the signal) is necessary. Typically this is archived using a single-level switch statement.
Callback functions communicate with the state machine engine through the \lstinline{qSM_Handler_t} and the return value of type \lstinline{qSM_Status_t}.

The semantic is simple, if a signal is processed, the callback functions returns the status value \lstinline{qSM_STATUS_SIGNAL_HANDLED}. otherwise it throws the signal for further processing by higher-level states. Also, this returning mechanism can be used to handle exceptions by using the surrounding callback.

\textit{Entry/Exit} actions and default transitions are also implemented inside the callback function in response of pre-defined signals. \lstinline{QSM_SIGNAL_ENTRY}, \lstinline{QSM_SIGNAL_EXIT} and \lstinline{QM_SIGNAL_START}.
The state machine generates and dispatches this signals to appropriates handlers upon state transitions.

The example below shows what a status callback should look like including the use of the handler.
\medskip

\begin{lstlisting}[style=CStyle]
qSM_Status_t ExampleState_Callback( qSM_Handler_t h ){
    switch( h ){
        case QSM_SIGNAL_START:
            break;
        case QSM_SIGNAL_ENTRY:
            break;
        case QSM_SIGNAL_EXIT:
            break;
        case USER_DEFINED_SIGNAL:
            h->NextState  =  &OtherState; /*transition*/
            break;
        default:
            break;
    }
    return qSM_STATUS_EXIT_SUCCESS;
}
\end{lstlisting} 

As shown above, the return value represents the exit status of the state, and it can be handled with an additional \textit{surrounding} callback function ($S_u$) established at the moment of the FSM setup. The values allowed to return are listed below.

\begin{itemize}
    \item \lstinline{qSM_STATUS_EXIT_SUCCESS}.
    \item \lstinline{qSM_STATUS_EXIT_FAILURE}.
    \item \lstinline{qSM_STATUS_SIGNAL_HANDLED}.
    \item Any other integer value between \lstinline{-32762} and \lstinline{32767}.
\end{itemize} 

The developer is free to write and control state transitions. A state jumps from one to another by changing the \lstinline{NextState} attribute. Transitions are only allowed under the availability of user-defined signals. Transitions are not allowed at an entry point (\lstinline{QSM_SIGNAL_ENTRY}), exit point (\lstinline{QSM_SIGNAL_EXIT}), or a start point (\lstinline{QSM_SIGNAL_START}).


\subsubsection{The surrounding callback}
It is a checkpoint before and after each state executes its activities through its state-callback. The behavior of this surrounding callback must be defined by the programmer.

\input{fig/surrounding}

When the surrounding callback is executed, it indicates its own checkpoint through the \lstinline{Status} attribute of the \lstinline{qSM_Handler_t} argument.

Unlike a state callback, the \textit{Surrounding} callback should not return anything, thus, the callback should be written as:
\medskip

\begin{lstlisting}[style=CStyle]
void SurroundingCallback_Example( qSM_Handler_t m ){
    switch( h->Status ){
        case qSM_STATUS_BEFORE_ANY:
            /* TODO: before any code */
            break;
        case qSM_STATUS_EXIT_FAILURE:
            /* TODO: success code */
            break;
        case qSM_STATUS_EXIT_SUCCESS:
            /* TODO: failure code */
            break;
        case qSM_STATUS_SIGNAL_HANDLED:
            /* TODO: failure code */
            break;            
        case 5: /*user defined return value*/ 
            /* TODO: used defined*/
            break;
        default: 
            /*handle the unexpected*/
            break
    }
}
\end{lstlisting}  

As you can see in the example below, the surrounding execution case its checked through the FSM handle by reading the \lstinline{Status} field.

\subsubsection{Running a state machine : \texorpdfstring{\lstinline{qStateMachine_Run}}{qStateMachine_Run} }

This API \index{\lstinline{qStateMachine_Run}} is used to execute the Finite State Machine. Only a single cycle is performed propagating the input signal until it is handled.
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t qStateMachine_Run( qSM_t * const m, qSM_Signal_t xSignal )
\end{lstlisting}

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{obj} : a pointer to the FSM object.
    \item \lstinline{xSignal} :  User-defined signal (this value will be ignored if the installed queue has items available)
\end{itemize}  

\subsubsection{Adding a state machine as a task : \texorpdfstring{\lstinline{qOS_Add_StateMachineTask}}{qOS_Add_StateMachineTask} } \label{statemachinetask}
The best strategy to run a FSM is delegating it to a task. For this, the provided \index{\lstinline{qOS_Add_StateMachineTask}} API should be used. Here, the task doesn't have a specific callback, instead, it will evaluate the active state of the FSM, and later, all the other possible states in response to events that mark their own transition. The task will be scheduled to run every \lstinline{Time} seconds in \lstinline{qPeriodic} mode. 

Using this API, the kernel will take care of the FSM by itself, so the usage of \lstinline{qStateMachine_Run()} can be omitted. 
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t qOS_Add_StateMachineTask( qTask_t * const Task, qSM_t *m, 
                                  qPriority_t Priority, 
                                  qTime_t Time, qState_t InitialTaskState,
                                  void *arg )
\end{lstlisting}

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{Task} : A pointer to the task node. 
    \item \lstinline{m} : A pointer to Finite State-Machine (FSM) object.
    \item \lstinline{Priority} : The priority value. [0(min) - \lstinline{Q_PRIORITY_LEVELS}(max)]
    \item \lstinline{Time} : Execution interval defined in seconds (floating-point format). For immediate execution use the  \lstinline{qTimeImmediate} definition. 
    \item \lstinline{InitialTaskState } : Specifies the initial operational state of the task (\lstinline{qEnabled}, \lstinline{qDisabled}, \lstinline{qAsleep} or \lstinline{qAwake}).
    \item \lstinline{arg} - Represents the task arguments. All arguments must be passed by reference and cast to \lstinline{(void *)}. 
\end{itemize}

\begin{tcolorbox}
\ArrowBoldDownRight \textit{Note}: For the \lstinline{Surrounding} argument, a \lstinline{NULL} value will act as a disable action.
\end{tcolorbox}

Now that a task is running a dedicated state-machine, the specific task event-info can be obtained in every state callback through the \lstinline{Data} field of the \lstinline{qSM_Handler_t} argument. Check the example below:
\medskip

\lstinputlisting[style=CStyle]{sec3fsmtaskinfo.c}

\subsubsection{A demonstrative example} \label{fsm_example}
In this example, one press of the button turn on the LED, a second push of the button will make the LED blink and if the button is pressed again, the LED will turn off. Also, our system must turn off the LED after a period of inactivity. If the button hasn't been pressed in the last 10 seconds, the LED will turn off. 

States ($\ S_i$) and transitions ($\ t_i$) are described as follows: 
\medskip
\begin{itemize}
\begin{minipage}{0.4\linewidth}
    \item $\ S_1$ : LED Off
    \item $\ S_2$ : LED On
    \item $\ S_3$ : LED Blink
\end{minipage}
\begin{minipage}{0.4\linewidth}
    \item $\ t_1$ : Button press (rising edge)
    \item $\ t_2$ : Timeout (10S)
\end{minipage}
\end{itemize}

\input{fig/fsmexample.tex}

To start the implementation, let's define the necessary global variables...

\begin{lstlisting}[style=CStyle]
qTask_t LED_Task; /*The task node*/
qSM_t LED_FSM; /*The state-machine handle*/
qSM_State_t State_LEDOff, State_LEDOn, State_LEDBlink;
\end{lstlisting}

Then, we define our states as the flow-diagram showed in figure \ref{fig:fsmexample}.

\lstinputlisting[style=CStyle]{sec3fsmledexample.c}

Finally, we add the task to the scheduling scheme running the dedicated state machine.

Remember that you must set up the scheduler before adding a task to the scheduling scheme.
\medskip

\begin{lstlisting}[style=CStyle]
qStateMachine_Setup( &LED_FSM, NULL, &State_LEDOff, NULL, NULL ); 
qStateMachine_StateSubscribe( &LED_FSM, &State_LEDOff, NULL, 
                              State_LEDOff_Callback, NULL, qFalse ); 
qStateMachine_StateSubscribe( &LED_FSM, &State_LEDOn, NULL, 
                              State_LEDOn_Callback, NULL, qFalse );
qStateMachine_StateSubscribe( &LED_FSM, &State_LEDBlink, NULL, 
                              State_LEDBlink_Callback, NULL, qFalse ); 
qOS_Add_StateMachineTask( &LED_Task, &LED_FSM, qHigh_Priority, 
                          0.1, qEnabled, NULL );
\end{lstlisting}


\subsubsection{Sending signals}
To communicate within and between state-machines or even other contexts, use signals. A signal is a simple value who can be used to abstract an incoming event. In the receiving state-machine, a queue or a exclusion variable receives the signal and holds it until the state-machine can evaluate it.

When coding state-machines, the application writer can benefit from this simple event-abstraction mechanism. On the one hand, there would be a more uniform programming when writing states callbacks and on the other hand, the communication of the state machine from other contexts becomes easier.

To send a signal to a state machine, use the following API:
\medskip

\begin{lstlisting}[style=CStyle]
 qBool_t qStateMachine_SendSignal( qSM_t * const m, qSM_Signal_t xSignal, 
                                   const qBool_t isUrgent )
\end{lstlisting} \index{\lstinline{qStateMachine_SendSignal}}

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{m} : A pointer to the FSM object. 
    \item \lstinline{xSignal} : The user-defined signal.
    \item \lstinline{isUrgent} : If \lstinline{qTrue}, the signal will be sent to the front of the queue. (only if the there is a signal-queue available)
\end{itemize}

\subsubsection*{Return Value}
\lstinline{qTrue} on success, otherwise returns \lstinline{qFalse}.

\lstinline{qFalse} if there is a queue, and the signal cannot be inserted because it is full or the exclusion variable has not been freed.

\hrulefill
\medskip

This API can manage their delivery to one of these possible destinations: an \textit{exclusion variable} or a \textit{signal queue}:
\begin{itemize}
    \item An \textit{exclusion variable} its a variable with an important distinction, it can only be written if it is empty. The empty situation only happens, if the engine has already propagated the signal within the state machine. If the signal has not yet propagated, the signal sending cannot be carried out.
    \item When a \textit{signal queue} is used, the signal is put into a FIFO structure and the engine takes care of dispatching the signal in an orderly manner. The only situation where the signal cannot be delivered is if the queue is full.
    This its the preferred destination, as long as there is a previously installed signal queue (for this, please review the next section.
\end{itemize}

\begin{tcolorbox}
\ArrowBoldDownRight \textit{Note}: If the signal-queue its available, the \lstinline{qStateMachine_SendSignal} will always select it as destination.
\end{tcolorbox}

\begin{tcolorbox}
\ArrowBoldDownRight If a state-machine, a task, or another context sends a signal to a full queue, an queue-overflow occurs. The result of the queue overflow it that the state-machine drops the new signal. 
\end{tcolorbox}

\subsubsection{Installing a signal queue}
A state machine can have a FIFO queue to allow the delivery of signals from another contexts. If the signal queue its installed, the state-machine engine constantly monitors the queue for available signals. The engine then propagates the signal through the hierarchy until it is processed. 
To enable this functionality in your state machine, the queue must be installed by using the \lstinline{qStateMachine_InstallSignalQueue} API.

The install operation should be performed after both, the queue and the FSM are correctly initialized by using \lstinline{qQueue_Setup} and \lstinline{qStateMachine_Setup} respectively.
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t qStateMachine_InstallSignalQueue( qSM_t * const m, qQueue_t *queue );
\end{lstlisting} \index{\lstinline{qStateMachine_InstallSignalQueue}}

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{m} : A pointer to the FSM object. 
    \item \lstinline{queue} : A pointer to the queue instance. 
\end{itemize}

\subsubsection*{Return Value}
\lstinline{qTrue} on success, otherwise returns \lstinline{qFalse}.

\hrulefill
\medskip

\begin{tcolorbox}
\ArrowBoldDownRight \textit{Note}: Make sure that queues are enabled in the \lstinline{qconfig.h}.
\end{tcolorbox}

\begin{tcolorbox}
\HandRight When configuring a signal queue with \lstinline{qQueue_Setup}, remember to size it based on the type \lstinline{qSM_Signal_t}.
\end{tcolorbox}

\begin{tcolorbox}
\HandRight If the state-machines its delegated to a task, make sure to install the queue prior to setting up the task. In this way, a kernel connection can be performed between the FSM signal-queue and the FSM-task, allowing the OS to catch signals to produce a task event, this prevents the wait of the task for the specified period, resulting in a faster handling of incoming signals.
\end{tcolorbox}

\subsubsection{Using a transition table}
In this approach, the FSM is coded in a table relating states and signal-events. 
This is an elegant method to translate the FSM to actual implementation as the handling for every state and event combination is encapsulated in the table. 

\begin{table}[H]
\centering
\begin{tabular}{||c c c c||} 
 \hline
 \textit{Current state} & \textit{Signal} & \textit{Signal action/guard} & \textit{Next state} \\ [0.5ex] 
 
 \hline\hline
 \ttfamily{StateA} & \ttfamily{Signal1} & \ttfamily{NULL} & \ttfamily{StateB}  \\ 
 \ttfamily{StateB} & \ttfamily{Signal3} & \ttfamily{DoOnSignal3} & \ttfamily{StateD} \\
 ... & ... & ... & ... \\
 \ttfamily{StateD} & \ttfamily{Signal6} & \ttfamily{NULL} & \ttfamily{StateA} \\ [1ex] 
 \hline
\end{tabular}
\caption{Transition table layout for the state-machine module}
\label{ttable_layout}
\end{table}

Here, the application writer get a quick picture of the FSM and the embedded software maintenance is also much more under control. A transition should be explicitly installed in the target FSM with the corresponding entries, an \textit{n}-sized array of \lstinline{qSM_Transition_t} elements. 

The API \lstinline{qStateMachine_InstallTransitionTable()}, should be used to perform the transition table installation to the target FSM.
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t qStateMachine_InstallTransitionTable( qSM_t * const m, 
                                              qSM_Transition_t * const table,
                                              const size_t n )
\end{lstlisting} \index{\lstinline{qStateMachine_InstallTransitionTable}}

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{m} : A pointer to the FSM object. 
    \item \lstinline{table} : The array of transitions (\lstinline{qSM_Transition_t[]}) that describes the state-machine behavior.. 
    \item \lstinline{n} : The number of transitions available within the \lstinline{table}.
\end{itemize}

\subsubsection*{Return Value}
Returns \lstinline{qTrue} on success, otherwise returns \lstinline{qFalse}.

\hrulefill

\subsubsection*{Caveats}
\begin{itemize}
    \item State transitions are not limited to the specification of the transition table. A state callback owns the higher precedence to change a state. The application writer can use both, a transition table and direct \lstinline{NextState} field manipulation in state callbacks to perform a transition to the FSM.
    \item Special care is required when the table grows very large, that is, when there are many invalid state/event combinations, leading to a waste of memory. There is also a memory penalty as the number of states and events grow. The application writer  need to accurately account for this during initial design. A statechart pattern can be used to improve the design and reduce the number of transition entries. 
    \item The user is responsible for defining the transitions according to the topology of the state machine. Undefined behaviors can occur if the topology is broken with poorly defined transitions.
\end{itemize}


\begin{tcolorbox}
\ArrowBoldDownRight \textit{Note}: When a transition entry is defined. the event-signal should be located as the second parameter of the entry. Please see the transition layout in table \ref{ttable_layout}.
\end{tcolorbox}

\subsubsection{Signal actions and guards:} 
Transition tables allow the usage of this feature. When an event-signal is received from the queue, the signal-action, if available, is evaluated before the transition is triggered. This action is user-defined and should be coded as a function that takes a \lstinline{qSM_Handler_t} object and returns a value of type \lstinline{qBool_t}. 
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t Signal_Action( qSM_Handler_t h ){
    /* TODO : Event-signal action*/
    return qTrue; /*allow the state transition*/
}
\end{lstlisting}

The return value is checked after to allow or reject the state transition. The application writer can code a boolean expression to implement statechart guards or perform some pre-transition procedure.

\begin{tcolorbox}
\HandRight If a signal-action returns \lstinline{qFalse}, the event-signal is rejected, preventing the state transition to be performed in the calling FSM.
\end{tcolorbox}

\begin{tcolorbox}
\ArrowBoldDownRight \textit{Note}: When a transition entry is defined. the signal-action should be located as the third parameter of the entry. Please see the transition layout in table \ref{ttable_layout}.
A \lstinline{NULL} value will act as a NOT-defined, always allowing the state-transition. 
\end{tcolorbox}


\subsubsection{FSM Timeout specification}
A timeout specification is mechanism to simplify the notion of time passage inside states. The basic usage model of the timeout signals is as follows:

An timeout specification allocates one or more timer objects. The user relates in a table each specific timeout with its respective state where it will operate. So, according to the table, when a state needs to arrange for a timeout, the engine can set or reset the given timer.  When the FSM engine detects that the appropriate moment has arrived (a timer expiration occurs), it inserts the timeout signal directly into the recipient's event queue. The recipient then processes the timeout signal just like any other signal.

Given the above explanation, it is evident that for its operation, the state machine requires an installed signal queue.

A timeout specification is referenced by an object of type \lstinline{qSM_TimeoutSpec_t} and must be installed inside the state machine using the API \lstinline{qStateMachine_InstallTimeoutSpec()}.
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t qStateMachine_InstallTimeoutSpec( qSM_t * const m,  
                                          qSM_TimeoutSpec_t * const ts, 
                                          qSM_TimeoutStateDefinition_t *tdef, 
                                          const size_t n );
\end{lstlisting} \index{\lstinline{qStateMachine_InstallTransitionTable}}

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{m} : A pointer to the FSM object. 
    \item \lstinline{ts} : A pointer to the timeout specification object.
    \item \lstinline{tdef} : The lookup table matching the target state and the requested timeout..
    \item \lstinline{n} : the number of elements inside \lstinline{tdef}.
\end{itemize}

\subsubsection*{Return Value}
Returns \lstinline{qTrue} on success, otherwise returns \lstinline{qFalse}.

\hrulefill

A timeout specification is defined as an structure of type \lstinline{qSM_TimeoutStateDefinition_t} and should follow this layout:

\begin{table}[H]
\centering
\begin{tabular}{||c c c||} 
 \hline
 \textit{Current state} & \textit{Timeout value} & \textit{Options} \\ [0.5ex] 
 \hline
\end{tabular}
\caption{Timeout specification layout}
\label{ttable_layout}
\end{table}

You can pass multiple specifications for a given state-machine by just creating a list in the form of array (\lstinline{qSM_TimeoutStateDefinition_t[]}).

The options for every timeout its a bitwise value that indicates which timeout should be used and the operations than should be performed internally by the state-machine engine. This options can be combined with a bitwise OR and are detailed as follows:

\begin{itemize}
    \item \lstinline{QSM_TSOPT_INDEX(index)} : To select the timeout to be used in the specification. Should be a value between \lstinline{0} and \lstinline{(Q_FSM_MAX_TIMEOUTS-1)}
    \item \lstinline{QSM_TSOPT_SET_ENTRY} : To set the timeout when the specified state its entering.
    \item \lstinline{QSM_TSOPT_RST_ENTRY} :  To reset the timeout when the specified state its entering.
    \item \lstinline{QSM_TSOPT_SET_EXIT} : To set the timeout when the specified state its exiting.
    \item \lstinline{QSM_TSOPT_RST_EXIT} : To reset the timeout when the specified state its exiting.
    \item \lstinline{QSM_TSOPT_KEEP_IF_SET} : To apply the Set operation only if the timeout its in a reset state.
    \item \lstinline{QSM_TSOPT_PERIODIC} : To put the timeout in periodic mode.
\end{itemize}

\begin{tcolorbox}
\HandRight The user is responsible for writing timeout specifications correctly. Care must be taken that the specifications do not collide between hierarchical states to avoid overwriting operations.
\end{tcolorbox}

\begin{tcolorbox}
\HandRight You can increase the number of available timeouts instances by changing the \lstinline{Q_FSM_MAX_TIMEOUTS} configuration macro inside \lstinline{qconfig.h}. 
\end{tcolorbox}

\subsubsection{Demonstrative example using a transition table}
The following example shows the implementation of the FSM presented in section \ref{fsm_example} using the transition table approach with signal-queue and a timeout specification.

Before getting started, the required variables should be defined: 
\medskip

\lstinputlisting[style=CStyle]{sec3fsmledttabledef.c}

Then, we define the callback for the states. Here, the \lstinline{BeforeAny} sub-state is defined to send the timeout signal. 
\medskip

\lstinputlisting[style=CStyle]{sec3fsmledttablestates.c}

In the previous code snippet, we assumed that \lstinline{SIGNAL_BUTTON_PRESSED} can be delivered from either the interrupt context or another task.

To finish the setup, a task is added to handle the FSM and then, the transition table can be installed with the other required objects.
\medskip

\lstinputlisting[style=CStyle]{sec3fsmledttablesetup.c}

\subsubsection{Demonstrative example using the hierarchical approach} 
In conventional state machine designs, all states are considered at the same level. The design does not capture the commonality that exists among states. In real life, many states handle most transitions in similar fashion and differ only in a few key components. Even when the actual handling differs, there is still some commonality. It is in these situations where the hierarchical designs makes the most sense.

A hierarchical state-machine is characterized by having compound states. A composite state is defined as state that has inner states and can be used as a decomposition mechanism that allows factoring of common behaviors and their reuse. And this is the biggest advantage of this design, because it captures the commonality by organizing the states as a hierarchy. The states at the higher level in hierarchy perform the common handling, while the lower level states inherit the commonality from higher level ones and perform the state specific functions.

This example takes the "Cruise Control" study case from \cite{gomaa}, a real-time system that manages the speed of an automobile based on inputs from the driver. 

The behavior of this system is state-dependent in that the executed actions correspond not only to the driver input, but also on the current state of the system and with the status of the engine and the brake. 

The figure \ref{fig:fsmej} illustrate the modeling of this system with the "Automated Control" state acting as composite.
\medskip

\input{fig/fsmej}

Before getting started, the required user-defined signals, variables, and entries of the transition table should be defined:
\medskip

\lstinputlisting[style=CStyle]{sec3fsmcruisectrlttabledef.c}

Then, signal-actions and state callbacks are later defined:
\medskip

\lstinputlisting[style=CStyle]{sec3fsmcruisectrlstates.c}

Finally, the dedicated task for the FSM and related objects are configured.
\medskip
\lstinputlisting[style=CStyle]{sec3fsmcruisectrlsetup.c}

\subsection{Co-Routines}
As showed in figure \ref{fig:coroutine}, a task coded as a Co-Routine, is just a task that allows multiple entry points for suspending and resuming execution at certain locations, this feature can bring benefits by improving the task cooperative scheme and providing a linear code execution for event-driven systems without complex state machines or full multi-threading.
\medskip

\input{fig/coroutine.tex}
    
The QuarkTS implementation uses the Duff's device approach, and is heavily inspired by the Knuth approach\cite{knuth}, Simon Tatham's Co-Routines in C \cite{tatham} and Adam Dunkels Protothreads \cite{dunkels}. This means that a \textit{local-continuation} variable is used to preserve the current state of execution at a particular place of the Co-Routine scope but without any call history or local variables. This brings benefits to lower RAM usage, but at the cost of some restrictions on how a Co-routine can be used.
\medskip

\textbf{Limitations and Restrictions}:

\begin{itemize}
    \item The stack of a Co-Routine  is not maintained when a yield is performed. This means variables allocated on the stack will loose their values. To overcome this, a variable that must maintain its value across a blocking call must be declared as \lstinline{static}.
    \item Calls to API functions that could cause the Co-Routine to block, can only be made from the Co-Routine  function itself - not from within a function called by the Co-Routine .
    \item The implementation does not permit yielding or blocking calls to be made from within a \lstinline{switch} statement.
\end{itemize}

\subsubsection{Coding a Co-Routine}
The application writer just needs to create the body of the Co-Routine . This means starting a Co-Routine segment with \lstinline{qCR_Begin} \index{\lstinline{qCR_Begin}} and end with \lstinline{qCR_End} statement \index{\lstinline{qCR_End}}. From now on, yields and blocking calls from the Co-Routine scope are allowed.
\medskip

\lstinputlisting[style=CStyle]{sec3coroutinecoding.c}  

The \lstinline{qCR_Begin} statement should be placed at the start of the task function in which the Co-routine runs. All C statements above the \lstinline{qCR_Begin} will be executed as if they were in an endless-loop each time the task is scheduled.

A \lstinline{qCR_Yield} \index{\lstinline{qCR_Yield}} statement return the CPU control back to the scheduler but saving the execution progress, thereby allowing other processing tasks to take place in the system. With the next task activation, the Co-Routine will resume the execution after the last \lstinline{qCR_Yield} statement.
\medskip

\begin{tcolorbox}
\HandRight All the Co-routine statements has the \textit{qCR} appended at the beginning of their name.
\end{tcolorbox}

\begin{tcolorbox}
\HandRight Co-Routine statements can only be invoked from the scope of the Co-Routine.
\end{tcolorbox}


\begin{tcolorbox}
\HandRight Do not use an endless-loop inside a Co-routine ,this behavior it's already hardcoded within the segment definition.
\end{tcolorbox}

\subsubsection{Blocking calls}
Blocking calls inside a Co-Routine should be made with the provided statements, all of them with a common feature: an implicit yield.

A widely used procedure is to wait for a fixed period of time. For this, the \lstinline{qCR_Delay()} should be used \index{\lstinline{qCR_Delay}}. 
\medskip


\begin{lstlisting}[style=CStyle]
qCR_Delay( qTime_t tDelay ) 
\end{lstlisting}

As expected, this statement makes an apparent blocking over the application flow, but to be precise, a yield is performed until the requested time expires, this allows other tasks to be executed until the blocking call finish. This \textit{"yielding until condition meet"} behavior its the common pattern among the other blocking statements.
\medskip

Another common blocking call is \lstinline{qCR_WaitUntil()} \index{\lstinline{qCR_WaitUntil}}:

\begin{lstlisting}[style=CStyle]
qCR_WaitUntil( Condition ) 
\end{lstlisting}

This statement takes a \lstinline{Condition} argument, a logical expression that will be performed when the Co-Routine resumes their execution. As mentioned before, this type of statement exposes the expected behavior, yielding until the condition is met.
\medskip

An additional wait statement is also provided that sets a timeout for the logical condition to be met, with a similar behavior of \lstinline{qCR_WaitUntil}. \index{\lstinline{qCR_TimedWaitUntil}}
\medskip

\begin{lstlisting}[style=CStyle]
qCR_TimedWaitUntil( Condition, qTime_t Timeout )
\end{lstlisting}

Optionally, the \lstinline{Do-Until} \index{\lstinline{qCR_Do}} \index{\lstinline{qCR_Until}} structure gives to application writer the ability to perform a multi-line job before the yield, allowing more complex actions to being performed after the Co-Routine resumes: 
\medskip

\begin{lstlisting}[style=CStyle]
qCR_Do{
    /* Job : a set of instructions*/
}qCR_Until( Condition );
\end{lstlisting}

\subsubsection*{Usage example:}
\lstinputlisting[style=CStyle]{sec3coroutinedem1.c}

\subsubsection{Positional jumps}
This feature provides positional local jumps, control flow that deviates from the usual Co-Routine call. 

The complementary statements \lstinline{qCR_PositionGet()} \index{\lstinline{qCR_PositionGet}} and \lstinline{qCR_PositionRestore()} \index{\lstinline{qCR_PositionRestore}} provide this functionality.
The first one saves the Co-Routine state at some point of their execution into \lstinline{CRPos}, a variable of type \lstinline{qCR_Position_t} \index{\lstinline{qCR_Position_t}},  that can be used at some later point of program execution by \lstinline{qCR_PositionRestore()} to restore the Co-Routine  state to the one saved by \lstinline{qCR_PositionGet()} into \lstinline{CRPos}. This process can be imagined to be a "jump" back to the point of program execution where \lstinline{qCR_PositionGet()} saved the Co-Routine  environment.
\medskip

\begin{lstlisting}[style=CStyle]
qCR_PositionGet( qCR_Position_t CRPos )
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
qCR_PositionRestore( qCR_Position_t CRPos )
\end{lstlisting}

And to reset the \lstinline{CRPos} variable to the beginning of the Co-Routine, use \index{\lstinline{qCR_PositionReset}}:

\begin{lstlisting}[style=CStyle]
qCR_PositionReset( qCR_Position_t CRPos )
\end{lstlisting}

\subsubsection{Semaphores}
This module implements counting semaphores on top of Co-Routines. Semaphores are a synchronization primitive that provide two operations: \textit{wait} and \textit{signal}. The \textit{wait} operation checks the semaphore counter and blocks the Co-Routine if the counter is zero. The \textit{signal} operation increases the semaphore counter but does not block. If another Co-Routine has blocked waiting for the semaphore that is signaled, the blocked Co-Routines will become runnable again.

Semaphores are referenced by handles, a variable of type \lstinline{qCR_Semaphore_t} \index{\lstinline{qCR_Semaphore_t}}and must be initialized with \lstinline{qCR_SemInit()} \index{\lstinline{qCR_SemInit}} before any usage.  Here, a value for the counter is required. Internally, semaphores use an \lstinline{unsigned int} to represent the counter, therefore the \lstinline{Value} argument should be within range of this data-type.
\medskip

\begin{lstlisting}[style=CStyle]
qCR_SemInit( qCR_Semaphore_t *sem, qUINT16_t Value )
\end{lstlisting}

To perform the \textit{wait} operation, the \lstinline{qCR_SemWait()} \index{\lstinline{qCR_SemWait}} statement should be used. The wait operation causes the Co-routine to block while the counter is zero. When the counter reaches a value larger than zero, the Co-Routine will continue.
\medskip


\begin{lstlisting}[style=CStyle]
qCR_SemWait( qCR_Semaphore_t *sem )
\end{lstlisting}

Finally, \lstinline{qCR_SemSignal()} \index{\lstinline{qCR_SemSignal}} carries out the \textit{signal} operation on the semaphore. This signaling increments the counter inside the semaphore, which eventually will cause waiting Co-routines to continue executing.
\medskip

\begin{lstlisting}[style=CStyle]
qCR_SemSignal( qCR_Semaphore_t *sem )
\end{lstlisting}


\subsubsection*{Usage example:}
The following example shows how to implement the bounded buffer problem using Co-Routines and semaphores. The example uses two tasks: one that produces items and other that consumes items.

Note that there is no need for a mutex to guard the \lstinline{add_to_buffer()} and \lstinline{get_from_buffer()} functions because of the implicit locking semantics of Co-Routines, so it will never be preempted and will never block except in an explicit \lstinline{qCR_SemWait} statement.
\medskip

\lstinputlisting[style=CStyle]{sec3coroutinedem2.c}

\subsubsection{External control}
There are several circumstances where becomes necessary to control the flow of execution outside the segment that defines the Co-routine itself. This is usually used to defer the job of the Co-routine or resume it in response to specific occurrences that arises in other contexts, either tasks or interrupts.

To code this specific situations, a handler to the Co-routine should be defined, a variable of type \lstinline{qCR_Handle_t}. In addition to this, the scope of the target Co-routine must be started with the \lstinline{qCR_BeginWithHandle} statement instead of \lstinline{qCR_Begin}.
\medskip

\lstinputlisting[style=CStyle]{sec3coroutinectrlext.c}

As seen in the code snippet above, the Co-routine handle its globally declared to allow other contexts to access it.  The example shows that another task can control the Co-routine using the \lstinline{qCR_ExternControl} API. The actions performed by this API can be only be effective after the handle instantiation, an operation that takes place once on the first call of the Co-routine.
\medskip

\begin{lstlisting}[style=CStyle]
void qCR_ExternControl( qCR_Handle_t h, const qCR_ExternAction_t action,  
                        const qCR_ExtPosition_t action )                      
\end{lstlisting}\index{\lstinline{qCR_ExternControl}}

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{h} : The Co-routine handle.
    \item \lstinline{action} : The specific action to perform, should be one of the following:
    \begin{itemize}
        \item \lstinline{qCR_RESTART} : Restart the Co-routine execution at the place of the \lstinline{qCR_BeginWithHandle} statement.  
        \item \lstinline{qCR_SUSPEND} :  Suspend the entire Co-routine segment. The task will still running instructions outside the segment.
        \item \lstinline{qCR_RESUME} : Resume the entire Co-routine segment at the point where it had been left before the suspension.
        \item \lstinline{qCR_POSITIONSET} : Force the coroutine execution at the position specified in \lstinline{pos}. If a non-valid position is supplied, the Co-routine segment will be suspended.      
    \end{itemize}
    \item \lstinline{pos} : The requested position if action = \lstinline{qCR_POSITIONSET}. For other actions this argument its ignored.  
\end{itemize}

\hrulefill
\medskip

\begin{tcolorbox}
\HandRight A \lstinline{NULL} initialization its mandatory on \lstinline{qCR_Handle_t} variables. Undefined behavior may occur if this step is ignored.
\end{tcolorbox}

\subsection{AT Command Line Interface} 
A command-line interface (CLI) is a way to interact directly with the software of an embedded system in the form of text commands and responses. It can be seen as a typed set of commands to produce a result, but here, the commands are typed in real-time by a user through a specific interface, for example, UART, USB, LAN, etc. 

A CLI is often developed to aid initial driver development and debugging. This CLI might become the interface (or one of the interfaces) used by a sophisticated end-user to interact with the product. Think of typing commands to control a machine, or perhaps for low-level access to the control system as a development tool, tweaking time-constants and monitoring low-level system performance during testing. 

\subsubsection{The components of the CLI}
The provided development API parses and handles input commands, following a simplified form of the extended AT-commands syntax. 

\input{fig/atparser.tex}

As seen in figure \ref{fig:atparser}, the CLI has a few components described below:
\begin{itemize}
    \item  \textit{Input Handler} : It is responsible for collecting incoming data from the \textit{input} in the form of ASCII characters inside a buffer. When this buffer is ready by receiving an \lstinline{EOL}(\textit{End-Of-Line}) byte, it notifies the \textit{validator} to perform the initial checks.
    \item \textit{Validator}: Take the input string and perform three checks over it:
    \begin{enumerate}
        \item The input matches one of the subscribed commands.
        \item The input matches one of the default commands.
        \item The input is unknown
    \end{enumerate}
    \item \textit{Pre-Parser}: Takes the input if the \textit{validator} asserts the first check. It is responsible for syntax validation and classification. Also, prepares the input argument for the next component.
    \item \textit{Callback or Post-Parser}: If input at the \textit{pre-parser} is valid, the respective command-callback is invoked. Here, the application writer is free to handle the command execution and the output response.
    \item \textit{Output printer} : Takes all the return status of the previous components to print out a response at the output.
\end{itemize}
\bigskip

\begin{tcolorbox}
\HandRight Here, \textit{Input} and \textit{Output} should be provided by the application writer, for example, if a UART interface is chosen, the input should take the received bytes from an ISR and the output is a function to print out a single byte.
\end{tcolorbox}

\subsubsection{Supported syntax} \label{atsyntax}

The syntax is straightforward and the rules are provided below:

\begin{itemize}
    \item All command lines must start with \lstinline{AT} and end with an \lstinline{EOL} character. By default, the CLI uses the carriage return character. (We will use \lstinline{<CR>} to represent a carriage return character in this document).
    \item AT commands are case-insensitive 
    \item Only four types of AT commands are allowed:
    \begin{itemize}
        \item \textbf{Acting} (\lstinline{QATCLI_CMDTYPE_ACT}) : This is the simplest type of commands that can be subscribed. Its normally used to execute the action that the command should do. This type doesn't take arguments or modifiers, for example,
        \begin{lstlisting}
        AT+CMD
        \end{lstlisting}
        \item \textbf{Read} (\lstinline{QATCLI_CMDTYPE_READ}) : This type of command allows you to read or test a value already configured for the specified parameter. Only one argument is allowed.
        \begin{lstlisting}
        AT+CMD?
        AT+CMD?PARAM1
        \end{lstlisting}        
        \item \textbf{Test} (\lstinline{QATCLI_CMDTYPE_TEST}) : These types of commands allow you to get the values that can be set for its parameters. No parameters are allowed here.
        \begin{lstlisting}
        AT+CMD=?
        \end{lstlisting}
        \item \textbf{Parameter Set} (\lstinline{QATCLI_CMDTYPE_PARA}) : These types of commands allow \textit{n} arguments to be passed for setting parameters, for example:
        \begin{lstlisting}
        AT+CMD=x,y
        \end{lstlisting}
    \end{itemize}
    If none of the types is given at the input, the command response will be \lstinline{ERROR}
    \item The possible output responses are:
    \begin{itemize}
        \item \lstinline{OK}: Indicates the successful execution of the command.
        \item \lstinline{ERROR}: A generalized message to indicate failure in executing the command. 
        \item \lstinline{UNKNOWN} : The input command its not subscribed.
        \item \lstinline{NOT ALLOWED} : The command syntax is not one of the allowed types.
        \item \lstinline{User-defined}: A custom output message defined by the application writer.
        \item \lstinline{NONE} : No response.
    \end{itemize}
\end{itemize}

All responses are followed by a \lstinline{<CR><LF>}.
\medskip

Errors generated during the execution of these AT commands could be due to the following reasons:
\begin{itemize}
    \item Incorrect syntax/parameters of the AT command
    \item Bad parameters or not allowed operations defined by the application writer.
\end{itemize}

In case of an error, the string \lstinline{ERROR} or \lstinline{ERROR:<error_no>} are displayed.

\subsubsection{Setting up an AT-CLI instance}
Before starting the CLI development, the corresponding instance must be defined; a data structure of type \lstinline{qATCLI_t} \index{\lstinline{qATCLI_t}}. 
The instance should be initialized using the \lstinline{qATCLI_Setup()} API \index{\lstinline{qATCLI_Setup}}. A detailed description of this function is shown bellow:
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t qATCLI_Setup( qATCLI_t * const cli, const qPutChar_t OutputFcn, 
                      char *Input, const size_t SizeInput, char *Output, 
                      const size_t SizeOutput, const char *Identifier, 
                      const char *OK_Response, const char *ERROR_Response, 
                      const char *NOTFOUND_Response, const char *term_EOL )
\end{lstlisting}

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{cli} : A pointer to the AT Command Line Interface instance. 
    \item \lstinline{OutputFcn} : The basic output-char wrapper function. All the CLI responses  will be printed-out through this function.
    \item \lstinline{Input} : A memory location to store the parser input (mandatory) 
    \item \lstinline{SizeInput} : The size of the memory allocated in \lstinline{Input}. 
    \item \lstinline{Output} : A memory location to store the parser output. If not used, pass \lstinline{NULL}.
    \item \lstinline{SizeOutput} : The size of the memory allocated in \lstinline{Output}. 
    \item \lstinline{Identifier} : The device identifier string. This string will be printed-out after a call to the \lstinline{AT_DEFAULT_ID_COMMAND}.
    \item \lstinline{OK_Response} : The output message when a command callback returns \lstinline{QATCLI_OK}. To use the default, pass \lstinline{NULL}.
    \item \lstinline{ERROR_Response} : The output message when a command callback returns \lstinline{QATCLI_ERROR} or any \lstinline{QATCLI_ERRORCODE(#)}. To use the default, pass \lstinline{NULL}.
    \item \lstinline{NOTFOUND_Response } : The output message when input doesn't match with any of  the available commands. To use the default, pass \lstinline{NULL}.
    \item \lstinline{term_EOL} : The \textit{End-Of-Line} string printed out after any of the parser messages. To use the default, pass \lstinline{NULL}. 
\end{itemize}

\subsubsection{Subscribing commands to the parser}
The AT CLI is able to subscribe any number of custom AT commands. For this, the 
\lstinline{qATCLI_CmdSubscribe()} \index{\lstinline{qATCLI_CmdSubscribe}} API should be used.

This function subscribes the CLI instance to a specific command with an associated callback function, so that next time the required command is sent to the CLI input, the callback function will be executed.
\medskip
The CLI module only analyzes commands that follow the simplified AT-Commands syntax already described in section \ref{atsyntax}.
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t qATCLI_CmdSubscribe( qATCLI_t * const cli, 
                             qATCLI_Command_t * const Command, 
                             const char *TextCommand, 
                             qATCLI_CommandCallback_t Callback, 
                             qATCLI_Options_t CmdOpt, void *param )
\end{lstlisting}

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{cli} : A pointer to the AT Command Line Inteface instance. 
    \item \lstinline{Command} :  A pointer to the AT command object.
    \item \lstinline{TextCommand} : The string (name) of the command we want to subscribe to. Since this service only handles AT commands, this string has to begin by the \lstinline{"at"} characters and should be in lower case.
    \item \lstinline{Callback} : The handler of the callback function associated to the command. Prototype: 
    \lstinline{qATCLI_Response_t xCallback(qATCLI_Handler_t, qATCLI_PreCmd_t )}
    \item \lstinline{CmdOpt} : This flag combines with a bitwise OR (|) the following information:
    \begin{itemize}
        \item \lstinline{QATCLI_CMDTYPE_PARA} : \lstinline{AT+cmd=x,y} is allowed. The execution of the callback function also depends on whether the number of argument is valid or not. Information about number of arguments is combined with a bitwise 'OR' : \lstinline{QATCLI_CMDTYPE_PARA | 0xXY} , where \lstinline{X} which defines maximum argument number for incoming command and \lstinline{Y} which defines minimum argument number for incoming command.
        \item \lstinline{QATCLI_CMDTYPE_TEST} : \lstinline{AT+cmd=?} is allowed. 
        \item \lstinline{QATCLI_CMDTYPE_READ} : \lstinline{AT+cmd?} is allowed. 
        \item \lstinline{QATCLI_CMDTYPE_ACT} : \lstinline{AT+cmd} is allowed. 
    \end{itemize}
    \item \lstinline{param} :  User storage pointer.
\end{itemize}

\subsubsection{Writing a command callback}
The command callback should be coded by the application writter. Here, the following prototype should be used:
\medskip

\begin{lstlisting}[style=CStyle]
qATCLI_Response_t CMD_Callback( qATCLI_Handler_t h ){
    /* TODO : The command callback */
}
\end{lstlisting}

The callback takes one argument of type \lstinline{qATCLI_Handler_t} and returns a single value.
\medskip
The input argument it's just a pointer to public data of the CLI instance where the command it subscribed to. From the callback context, can be used to print out extra information as a command response, parse the command parameters, and query properties with crucial information about the detected command, like the type, the number of arguments, and the subsequent string after the command text. The members are described as follows:

\begin{itemize}
    \item \lstinline{Command} (read-only) : A pointer to the calling AT Command object.
    \item \lstinline{Type} (read-only) : The command type.
    \item \lstinline{StrData} (read-only) : The string data after the command text.
    \item \lstinline{StrLen} (read-only) : The length of \lstinline{StrData}.
    \item \lstinline{NumArgs} (read-only) : Number of arguments, only available if \lstinline{Type = QATCLI_CMDTYPE_PARA}.
    \item \lstinline{Output} : Points to the output buffer storage area.
    \item \lstinline{UserData} : Points to the user-defined data - Storage Pointer
    
    This argument also includes helper methods to write the output and retrieve command arguments:
    
    \item \lstinline{void puts(const char* s)} : Writes the string \lstinline{s} to the output.
    \item \lstinline{void putch(const char c)} : Writes the byte \lstinline{c} to the output.
    \item \lstinline{char* GetArgPtr( qIndex_t n )} : Get the pointer where the desired argument starts.
    \item \lstinline{int GetArgInt( qIndex_t n )} : Get the \lstinline{n} argument parsed as integer.
    \item \lstinline{qUINT32_t GetArgHex( qIndex_t n )} : Get the \lstinline{n} HEX argument parsed as \lstinline{qUINT32_t}.
    \item \lstinline{qFloat32_t GetArgFlt( qIndex_t n )} : Get the \lstinline{n} argument parsed as float.
    \item \lstinline{char* GetArgString( qIndex_t n, char *out )} :  get the argument \lstinline{n} by copying the string into \lstinline{out}.
\end{itemize}

The return value (an enum of type \lstinline{qATCLI_Response_t}) \index{\lstinline{qATCLI_Response_t}} determines the response shown by the \textit{Output printer} component. The possible allowed values are:

\begin{itemize}
    \item \lstinline{QATCLI_OK} : as expected, print out the \lstinline{OK} string.
    \item \lstinline{QATCLI_ERROR} : as expected, print out the \lstinline{ERROR} string.
    \item \lstinline{QATCLI_ERRORCODE(no)} : Used to indicate an error code. This code is defined by the application writer and should be a value between 1 and 32766. For example, a return value of \lstinline{QATCLI_ERRORCODE(15)}, will print out the string \lstinline{ERROR:15}.
    \item \lstinline{QATCLI_NORESPONSE} : No response will be printed out.
\end{itemize}


A simple example of how the command callback should be coded is showed below:
\medskip

\lstinputlisting[style=CStyle]{sec3atclicallback.c}


\subsubsection{Handling the input}
Input handling is simplified using the provided APIs. The \lstinline{qATCLI_ISRHandler()} \index{\lstinline{qATCLI_ISRHandler}} and \lstinline{qATCLI_ISRHandlerBlock()}  \index{\lstinline{qATCLI_ISRHandlerBlock}} functions are intended to be used from the interrupt context. This avoids any kind of polling implementation and allows the CLI application to be designed using an event-driven pattern.
\medskip
\begin{lstlisting}[style=CStyle]
qBool_t qATCLI_ISRHandler( qATCLI_t * const cli, char c )
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
qBool_t qATCLI_ISRHandlerBlock( qATCLI_t * const cli, char *data, 
                                const size_t n )
\end{lstlisting}

Both functions feed the parser input, the first one with a single character and the second with a string. The application writer should call one of these functions from the desired hardware interface, for example, from a UART receive ISR. 

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{cli} : Both APIs take a pointer to AT Command Line Interface instance.
\end{itemize}

for \lstinline{qATCLI_ISRHandler} :
\begin{itemize}
    \item \lstinline{c} : The incoming byte/char to the input. 
\end{itemize}

for \lstinline{qATCLI_ISRHandlerBlock} :
\begin{itemize}
    \item \lstinline{data} : The incoming string.
    \item \lstinline{n} : The length of the \lstinline{data} argument.
\end{itemize}

\subsubsection*{Return Value}
\lstinline{qTrue} when the CLI is ready to process the input, otherwise return \lstinline{qFalse}.

\noindent\hrulefill
\newline
If there are no intention to feed the input from the ISR context, the APIs \lstinline{qATCLI_Raise} \index{\lstinline{qATCLI_Raise}} or \lstinline{qATCLI_Exec} \index{\lstinline{qATCLI_Exec}} can be called at demand from the base context.
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t qATCLI_Raise( qATCLI_t * const cli, const char *cmd )
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
qATCLI_Response_t qATCLI_Exec( qATCLI_t * const cli, const char *cmd )
\end{lstlisting}

As expected, both functions send the string to the specified CLI.
The difference between both APIs is that \lstinline{qATCLI_Raise()} sends the command through the input, marking it as ready for parsing and acting as the \textit{Input handler} component.

The \lstinline{qATCLI_Exec()}, on the other hand, executes the components of \textit{Pre-parsing} and \textit{Post-parsing} bypassing the other components, including the \textit{Output printer}, so that it must be handled by the application writer.

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{cli} : A pointer to the AT Command Line Inteface instance.
    \item \lstinline{cmd} : The command string, including arguments if required.
\end{itemize}

\subsubsection*{Return value:}
For \lstinline{qATCLI_Raise()}, \lstinline{qTrue} if the command was successfully raised, otherwise returns \lstinline{qFalse}.

For \lstinline{qATCLI_Exec()}, the same value returned by the respective callback function. If the input string doesn't match any of the subscribed commands, returns \lstinline{QAT_NOTFOUND}. If the input syntax is not allowed, returns \lstinline{qAT_NOTALLOWED}. 
\medskip

\begin{tcolorbox}
\ArrowBoldDownRight \textit{Note}: All functions involved with the component \textit{Input-handler},  ignores non-graphic characters and cast any uppercase to lowercase.
\end{tcolorbox}

\subsubsection{Running the parser} \label{runningparser}
The parser can be invoked directly using the \lstinline{qATCLI_Run()} \index{\lstinline{qATCLI_Run}} API. Almost all the components that make up the CLI are performed by this API, except for the \textit{Input Handler}, that should be managed by the application writer itself.
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t qATCLI_Run( qATCLI_t * const Parser )
\end{lstlisting}

In this way, the writer of the application must implement the logic that leads this function to be called when the \textit{input-ready} condition is given.

The simple approach for this is to check the return value of any of the input feeder APIs and set a notification variable when they report a ready input. Later in the base context, a polling job should be performed over this notification variable, running the parser when their value is true, then clearing the value after to avoid unnecessary overhead. 

The recommended implementation is to leave this job be handled by a task instead of coding the logic to know when the CLI should run. For this, the \lstinline{qOS_Add_ATCLITask()} is provided. This API \index{\lstinline{qOS_Add_ATCLITask}} add a task to the scheduling scheme running an AT Command Line Interface and treated as an event-triggered task. The address of the parser instance will be stored in the \lstinline{TaskData} storage-Pointer.
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t qOS_Add_ATCLITask( qTask_t * const Task, 
                           qATCLI_t *cli, 
                           qPriority_t Priority )
\end{lstlisting}

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{Task} : A pointer to the task node. 
    \item \lstinline{Parser} :  A pointer to the AT Command Line Interface instance.
    \item \lstinline{Priority} : Task priority Value. [0(min) - \lstinline{Q_PRIORITY_LEVELS}(max)]
\end{itemize}

After invoked, both CLI and task are linked together in such a way that when an \textit{input-ready} condition is given, a notification event is sent to the task launching the CLI components. As the task is event-triggered, there is no additional overhead and the writer of the application can assign a priority value to balance the application against other tasks in the scheduling scheme.

\subsubsection{CLI Example}

The following example demonstrates the usage of a simple command-line interface using the UART peripheral with two subscribed commands :

\begin{itemize}
    \item A command to write and read the state of a GPIO pin \lstinline{at+gpio}.
    \item A command to retrieve the compilation timestamp \lstinline{at+info}.
\end{itemize}

First, lets get started defining the required objects to setup the CLI module:
\medskip

\lstinputlisting[style=CStyle]{sec3cliexamplep1.c}

Then the CLI instance its configured by subscribing commands and adding the task to the OS. A wrapper function its required here to make the UART output-function compatible with the CLI API.

\lstinputlisting[style=CStyle]{sec3cliexamplep2.c}

The CLI input its feeded from the interrupt context by using the UART receive ISR:

\lstinputlisting[style=CStyle]{sec3cliexamplep3.c}

Finally, the command-callbacks are later defined to perform the requested operations.

\lstinputlisting[style=CStyle]{sec3cliexamplep4.c}

\subsection{Memory Management} \label{memmanagement}
As the OS is targered to build safe-critical embedded applications, dynamic memory allocation its not allowed for the kernel design, because can lead to out-of-storage run-time failures, which are undesirable. However, some applications can be easily deployed using this allocation scheme, so a safe and portable implementation becomes relevant in the scope of the user-code. 

In a typical C environment, memory can be allocated using the standard library functions  \textit{malloc()} and \textit{free()}, but they may not be suitable in most embedded applications because they are not always available on small microcontrollers or their implementation can be relatively large, taking up valuable code space. Also, there is a range of unspecified and implementation-defined behaviour associated with dynamic memory allocation, as well as a number of other potential pitfalls. Additionally, some implementations can suffer from fragmentation.

To get around this problem, the OS provides its own memory-management interface for dynamic allocation as a fully kernel-independent module. When the application requires RAM, instead of calling \textit{malloc()},  call \lstinline{qMalloc()} \index{\lstinline{qMalloc}}. When RAM is being freed, instead of calling \textit{free()}, use \lstinline{qFree()} \index{\lstinline{qFree}}. Both functions have the same prototype as the standard C library counterparts.

\subsubsection{Principle of operation}
The allocation scheme works by subdividing a static array into smaller blocks and using the \textit{First-Fit} approach (see figure \ref{fig:memman}). 

\input{fig/memman.tex}

If adjacent free blocks are available, the implementation combines them into a single larger block, minimizing the risk of fragmentation, making it suitable for applications that repeatedly allocate and free different sized blocks of RAM.

\begin{tcolorbox}
\ArrowBoldDownRight \textit{Note}: Because memory is statically declared, it will make the application appear to consume a lot of RAM, even before any memory has been allocated from it.
\end{tcolorbox}

\begin{tcolorbox}
\AsteriskBold \textit{Warning}: All the memory management APIs are NOT interrupt-safe. Use these APIs only from the base context.
\end{tcolorbox}

\begin{tcolorbox}
\AsteriskBold \textit{Warning}: The application is not exempt from memory leaks if the user does not perform adequate memory management. Here, the worst case scenario can occur in the absence of free memory. 
\end{tcolorbox}

\subsubsection{Memory pools}

A memory pool its a special resource that allows memory blocks to be dynamically allocated from a user-designated memory region. Instead of typical pools with fixed-size block allocation, the pools in QuarkTS can be of any size, thereby the user is responsible for selecting the appropriate memory pool to allocate data with the same size. 

The \textit{default} memory management unit resides in a memory pool object. Also called the \textit{default pool}. The total amount of available heap space in the default memory pool is set by \lstinline{Q_DEFAULT_HEAP_SIZE}, which is defined in \lstinline{qconfig.h}.

Besides the \textit{default} pool, any number of additional memory pools can be defined. Like any other object in QuarkTS, memory pools are referenced by handles, a variable of type \lstinline{qMemMang_Pool_t} \index{\lstinline{qMemMang_Pool_t}} and should be initialized before use with the \lstinline{qMemMang_Pool_Setup()} \index{\lstinline{qMemMang_Pool_Setup}} API function.
\medskip

\begin{lstlisting}[style=CStyle]
qBool_t qMemMang_Pool_Setup( qMemMang_Pool_t * const mPool, void* Area, 
                             size_t size )
\end{lstlisting}

\subsubsection*{Parameters}
\begin{itemize}
    \item \lstinline{mPool} : A pointer to the memory pool instance. 
    \item \lstinline{Area} :  A pointer to a memory region (\lstinline{qUINT8_t}) statically allocated to act as Heap of the memory pool. The size of this block should match the \lstinline{size} argument.
    \item \lstinline{size} : The size of the memory block pointed by \lstinline{Area}. 
\end{itemize}

To perform operations in another memory pool, besides the \textit{default} pool, an explicit switch should be performed using \lstinline{qMemMang_Pool_Select()} \index{\lstinline{qMemMang_Pool_Select}}. Here, a pointer to the target pool should be passed as input argument.  From now on, every call to \lstinline{qMalloc()}, or \lstinline{qFree()} will run over the newly selected memory pool. To return to  the \textit{default pool},  a new call to  \lstinline{qMemMang_Pool_Select()} is required passing \lstinline{NULL} as input argument. 
\medskip

\begin{lstlisting}[style=CStyle]
void qMemMang_Pool_Select( qMemMang_Pool_t * const mPool )
\end{lstlisting}

To keep track of the memory usage, the \lstinline{qMemMang_Get_FreeSize()} \index{\lstinline{qMemMang_Get_FreeSize}} API function returns the number of free bytes in the memory pool at the time the function is called.
\medskip

\begin{lstlisting}[style=CStyle]
size_t qMemMang_Get_FreeSize( void )
\end{lstlisting}

\subsubsection*{Usage example:}

\lstinputlisting[style=CStyle]{sec3memmangdem1.c}

\subsection{Trace and debugging}
QuarkTS include some basic macros to print out debugging messages. Messages can be simple text or the value of variables in specific base-formats. 
To use the trace macros, a single-char output function must be defined using the \lstinline{qTrace_Set_OutputFcn()} macro.\index{\lstinline{qTrace_Set_OutputFcn}}
\medskip

\begin{lstlisting}[style=CStyle]
qTrace_Set_OutputFcn( qPutChar_t fcn )
\end{lstlisting}

Where \lstinline{fcn} is a pointer to the single-char output function following the prototype:
\medskip

\begin{lstlisting}[style=CStyle]
void SingleChar_OutputFcn( void *sp, const char c ){
    /*
    TODO : print out the c variable using the
    selected peripheral.
    */
}
\end{lstlisting}

The body of this user-defined function should have a hardware-dependent code to print out the \lstinline{c} variable through a specific peripheral.

\subsubsection{Viewing variables}
For viewing or tracing a variable (up to 32-bit data) through debug, one of the following macros are available:
\index{\lstinline{qTrace_Var}} \index{\lstinline{qTrace_Variable}} \index{\lstinline{qDebug_Var}} \index{\lstinline{qDebug_Variable}}
\medskip

\begin{lstlisting}[style=CStyle]
qTrace_Var( Var, DISP_TYPE_MODE )
qTrace_Variable( Var, DISP_TYPE_MODE )
\end{lstlisting}
\begin{lstlisting}[style=CStyle]
qDebug_Var( Var, DISP_TYPE_MODE )
qDebug_Variable( Var, DISP_TYPE_MODE )
\end{lstlisting}

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{Var} : The target variable. 
    \item \lstinline{DISP_TYPE_MODE } :  Visualization mode. It must be one of the following parameters(case sensitive): \lstinline{Bool}, \lstinline{Float}, \lstinline{Binary}, \lstinline{Octal}, \lstinline{Decimal}, \lstinline{Hexadecimal}, \lstinline{UnsignedBinary}, \lstinline{UnsignedOctal}, \lstinline{UnsignedDecimal}, \lstinline{UnsignedHexadecimal}. 
\end{itemize}

The only difference between \lstinline{qTrace_} and  \lstinline{Debug}, is that \lstinline{qTrace_} macros, print out additional information provided by the \lstinline{__FILE__}, \lstinline{__LINE__} and \lstinline{__func__} built-in preprocessing macros, mostly available in common C compilers. 

\subsubsection{Viewing a memory block}
For tracing memory from a specified target address, one of the following macros are available: \index{\lstinline{qTrace_Mem}} \index{\lstinline{qTrace_Memory}}

\begin{lstlisting}[style=CStyle]
qTrace_Mem( Pointer, BlockSize )
qTrace_Memory( Pointer, BlockSize )
\end{lstlisting}

\subsubsection*{Parameters:}
\begin{itemize}
    \item \lstinline{Pointer} : The target memory address.
    \item \lstinline{Size} : Number of bytes to be visualized.
\end{itemize}

Hexadecimal notation it's used to format the output of these macros.

\subsubsection{Usage}

In the example below, an UART output function is coded to act as the printer. Here, the target MCU is an ARM-Cortex M0 with the UART1 as the selected peripheral for this purpose.
\medskip

\begin{lstlisting}[style=CStyle]
void putUART1( void *sp, const char c ){
    /* hardware specific code */
    UART1_D = c;
    while ( !(UART1_S1 & UART_S1_TC_MASK) ) {} /*wait until TX is done*/ 
}
\end{lstlisting}  

As seen above, the function follows the required prototype. Later, in the main thread, a call to the \lstinline{qSetDebugFcn()} is used to set up the output-function.

\begin{lstlisting}[style=CStyle]
int main( void ){
   qTrace_Set_OutputFcn( putUART1 );
   ... 
   ...
}
\end{lstlisting}  

After that, trace macros will be available for use.

\begin{lstlisting}[style=CStyle]
void IO_TASK_Callback( qEvent_t e ){
   static qUINT32_t Counter = 0;
   float Sample;
   ...
   ... 
   qTrace_Message( "IO TASK running..." );
   Counter++;
   qTrace_Variable( Counter, UnsignedDecimal );
   Sample = SensorGetSample();
   qTrace_Variable( Sample, Float );
   ...
   ...
}
\end{lstlisting}

\newpage